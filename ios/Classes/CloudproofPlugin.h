#import <Flutter/Flutter.h>

@interface CloudproofPlugin : NSObject<FlutterPlugin>
@end
// NOTE: Autogenerated file

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The number of seconds of validity of the requests to the `FindexREST` server.
 * After this time, the request cannot be accepted by the backend. This is done
 * to prevent replay attacks.
 */
#define REQUEST_SIGNATURE_TIMEOUT_AS_SECS 60

/**
 * Callback signature length.
 */
#define SIGNATURE_LENGTH 32

/**
 * Seed used to generate KMAC keys.
 */
#define SIGNATURE_SEED_LENGTH 16

#define INDEX_ID_LENGTH 5

/**
 * The Key Length: 256 bit = 32 bytes for AES 256
 */
#define KEY_LENGTH 32

/**
 * The recommended threshold according to NIST standards
 */
#define RECOMMENDED_THRESHOLD 1000000

typedef int32_t (*Interrupt)(const uint8_t *intermediate_results_ptr,
                             uint32_t intermediate_results_len);

/**
 * # Serialization
 *
 * Input:
 * `LEB128(n_uids) || UID_1 || ...`
 *
 * Output:
 * `LEB128(n_entries) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int32_t (*Fetch)(uint8_t *output_ptr,
                         uint32_t *output_len,
                         const uint8_t *uids_ptr,
                         uint32_t uids_len);

/**
 * # Serialization
 *
 * Input:
 * `LEB128(n_values) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 *
 * Output:
 * `LEB128(n_lines) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int32_t (*Upsert)(uint8_t *indexed_values_ptr,
                          uint32_t *indexed_values_len,
                          const uint8_t *old_values_ptr,
                          uint32_t old_values_len,
                          const uint8_t *new_values_ptr,
                          uint32_t new_values_len);

/**
 * # Serialization
 *
 * Input:
 * `LEB128(n_values) || UID_1 || LEB128(value_1.len() || value_1 || ...`
 */
typedef int32_t (*Insert)(const uint8_t *input_ptr, uint32_t input_len);

/**
 * # Serialization
 *
 * Input:
 * `LEB128(n_values) || UID_1 || LEB128(value_1.len() || value_1 || ...`
 */
typedef int32_t (*Delete)(const uint8_t *input_ptr, uint32_t input_len);

/**
 * # Serialization
 *
 * Output: `LEB128(n_uids) || UID_1 || ... || UID_n`
 */
typedef int32_t (*DumpTokens)(uint8_t *uids_ptr, uint32_t *uids_len);

typedef int32_t (*FilterObsoleteData)(uint8_t *output_locations_ptr,
                                      uint32_t *output_locations_len,
                                      const uint8_t *locations_ptr,
                                      uint32_t locations_len);

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

int32_t h_aes256gcm_encrypt(uint8_t *output_ptr,
                            int32_t *output_len,
                            const int8_t *plaintext_ptr,
                            int32_t plaintext_len,
                            const int8_t *key_ptr,
                            int32_t key_len,
                            const int8_t *nonce_ptr,
                            int32_t nonce_len,
                            const int8_t *authenticated_data_ptr,
                            int32_t authenticated_data_len);

int32_t h_aes256gcm_decrypt(uint8_t *output_ptr,
                            int32_t *output_len,
                            const int8_t *ciphertext_ptr,
                            int32_t ciphertext_len,
                            const int8_t *key_ptr,
                            int32_t key_len,
                            const int8_t *nonce_ptr,
                            int32_t nonce_len,
                            const int8_t *authenticated_data_ptr,
                            int32_t authenticated_data_len);

/**
 * Externally sets the last error recorded on the Rust side.
 *
 * # Safety
 *
 * The pointer must point to a null-terminated string.
 *
 * This function is meant to be called from the Foreign Function
 * Interface.
 *
 * # Parameters
 *
 * - `error_message_ptr`   : pointer to the error message to set
 */
int32_t h_set_error(const int8_t *error_message_ptr);

/**
 * Externally gets the most recent error recorded on the Rust side, clearing
 * it in the process.
 *
 * # Safety
 *
 * The pointer `error_ptr` should point to a buffer which has been allocated
 * `error_len` bytes. If the allocated size is smaller than `error_len`, a
 * call to this function may result in a buffer overflow.
 *
 * # Parameters
 *
 * - `error_ptr`: pointer to the buffer to which to write the error
 * - `error_len`: size of the allocated memory
 */
int32_t h_get_error(int8_t *error_ptr, int32_t *error_len);

/**
 * # Safety
 */
int32_t h_policy(int8_t *policy_ptr, int32_t *policy_len);

/**
 * # Safety
 */
int32_t h_add_policy_axis(int8_t *updated_policy_ptr,
                          int32_t *updated_policy_len,
                          const int8_t *current_policy_ptr,
                          int32_t current_policy_len,
                          const int8_t *axis_ptr);

/**
 * # Safety
 */
int32_t h_remove_policy_axis(int8_t *updated_policy_ptr,
                             int32_t *updated_policy_len,
                             const int8_t *current_policy_ptr,
                             int32_t current_policy_len,
                             const int8_t *axis_name_ptr);

/**
 * # Safety
 */
int32_t h_add_policy_attribute(int8_t *updated_policy_ptr,
                               int32_t *updated_policy_len,
                               const int8_t *current_policy_ptr,
                               int32_t current_policy_len,
                               const int8_t *attribute,
                               bool is_hybridized);

/**
 * # Safety
 */
int32_t h_remove_policy_attribute(int8_t *updated_policy_ptr,
                                  int32_t *updated_policy_len,
                                  const int8_t *current_policy_ptr,
                                  int32_t current_policy_len,
                                  const int8_t *attribute);

/**
 * # Safety
 */
int32_t h_disable_policy_attribute(int8_t *updated_policy_ptr,
                                   int32_t *updated_policy_len,
                                   const int8_t *current_policy_ptr,
                                   int32_t current_policy_len,
                                   const int8_t *attribute);

int32_t h_rename_policy_attribute(int8_t *updated_policy_ptr,
                                  int32_t *updated_policy_len,
                                  const int8_t *current_policy_ptr,
                                  int32_t current_policy_len,
                                  const int8_t *attribute,
                                  const int8_t *new_attribute_name_ptr);

/**
 * # Safety
 */
int32_t h_rotate_attribute(int8_t *updated_policy_ptr,
                           int32_t *updated_policy_len,
                           const int8_t *current_policy_ptr,
                           int32_t current_policy_len,
                           const int8_t *attribute);

/**
 * # Safety
 */
int32_t h_clear_old_attribute_values(int8_t *updated_policy_ptr,
                                     int32_t *updated_policy_len,
                                     const int8_t *current_policy_ptr,
                                     int32_t current_policy_len,
                                     const int8_t *attribute);

/**
 * # Safety
 */
int32_t h_validate_boolean_expression(const int8_t *boolean_expression_ptr);

/**
 * # Safety
 */
int32_t h_validate_attribute(const int8_t *attribute_ptr);

/**
 * Generates the master authority keys for supplied Policy.
 *
 *  - `msk_ptr`    : Output buffer containing the master secret key
 *  - `msk_len`    : Size of the master secret key output buffer
 *  - `mpk_ptr`    : Output buffer containing the master public key
 *  - `mpk_len`    : Size of the master public key output buffer
 *  - `policy_ptr` : Policy to use to generate the keys
 *  - `policy_len` : Size of the `Policy` to use to generate the keys
 *
 * # Safety
 */
int32_t h_generate_master_keys(int8_t *msk_ptr,
                               int32_t *msk_len,
                               int8_t *mpk_ptr,
                               int32_t *mpk_len,
                               const int8_t *policy_ptr,
                               int32_t policy_len);

/**
 * Generates a user secret key for the given access policy
 *
 * - `usk_ptr`             : Output buffer containing user secret key
 * - `usk_len`             : Size of the output buffer
 * - `msk_ptr`             : Master secret key (required for this generation)
 * - `msk_len`             : Master secret key length
 * - `user_policy_ptr`     : null terminated access policy string
 * - `policy_ptr`          : bytes of the policy used to generate the keys
 * - `policy_len`          : length of the policy (in bytes)
 * # Safety
 */
int32_t h_generate_user_secret_key(int8_t *usk_ptr,
                                   int32_t *usk_len,
                                   const int8_t *msk_ptr,
                                   int32_t msk_len,
                                   const int8_t *user_policy_ptr,
                                   const int8_t *policy_ptr,
                                   int32_t policy_len);

/**
 * Updates the master keys according to the given policy.
 *
 * Cf (`CoverCrypt::update_master_keys`)[`CoverCrypt::update_master_keys`].
 *
 * - `updated_msk_ptr` : Output buffer containing the updated master secret key
 * - `updated_msk_len` : Size of the updated master secret key output buffer
 * - `updated_mpk_ptr` : Output buffer containing the updated master public key
 * - `updated_mpk_len` : Size of the updated master public key output buffer
 * - `current_msk_ptr` : current master secret key
 * - `current_msk_len` : current master secret key length
 * - `current_mpk_ptr` : current master public key
 * - `current_mpk_len` : current master public key length
 * - `policy_ptr`      : Policy to use to update the master keys (JSON)
 * # Safety
 */
int32_t h_update_master_keys(int8_t *updated_msk_ptr,
                             int32_t *updated_msk_len,
                             int8_t *updated_mpk_ptr,
                             int32_t *updated_mpk_len,
                             const int8_t *current_msk_ptr,
                             int32_t current_msk_len,
                             const int8_t *current_mpk_ptr,
                             int32_t current_mpk_len,
                             const int8_t *policy_ptr,
                             int32_t policy_len);

/**
 * Refreshes the user secret key according to the given master key and access
 * policy.
 *
 * Cf [`CoverCrypt::refresh_user_secret_key()`](CoverCrypt::refresh_user_secret_key).
 *
 * - `updated_usk_ptr`                 : Output buffer containing the updated
 *   user secret key
 * - `updated_usk_len`                 : Size of the updated user secret key
 *   output buffer
 * - `msk_ptr`                         : master secret key
 * - `msk_len`                         : master secret key length
 * - `current_usk_ptr`                 : current user secret key
 * - `current_usk_len`                 : current user secret key length
 * - `access_policy_ptr`               : Access policy of the user secret key
 *   (JSON)
 * - `policy_ptr`                      : Policy to use to update the master
 *   keys (JSON)
 * - `preserve_old_partitions_access`  : set to 1 to preserve the user access
 *   to the rotated partitions
 * # Safety
 */
int32_t h_refresh_user_secret_key(int8_t *updated_usk_ptr,
                                  int32_t *updated_usk_len,
                                  const int8_t *msk_ptr,
                                  int32_t msk_len,
                                  const int8_t *current_usk_ptr,
                                  int32_t current_usk_len,
                                  const int8_t *user_policy_ptr,
                                  const int8_t *policy_ptr,
                                  int32_t policy_len,
                                  int32_t preserve_old_partitions_access);

/**
 * Creates a cache containing the Public Key and Policy. This cache can be
 * reused when encrypting messages which avoids passing these objects to Rust
 * in each call.
 *
 * WARNING: [`h_destroy_encrypt_cache()`](h_destroy_encryption_cache)
 * should be called to reclaim the cache memory.
 *
 * # Safety
 */
int32_t h_create_encryption_cache(int32_t *cache_handle,
                                  const int8_t *policy_ptr,
                                  int32_t policy_len,
                                  const int8_t *mpk_ptr,
                                  int32_t mpk_len);

/**
 * Reclaims the memory of the cache.
 *
 * Cf [`h_create_encrypt_cache()`](h_create_encryption_cache).
 *
 * # Safety
 */
int32_t h_destroy_encryption_cache(int32_t cache_handle);

/**
 * Encrypts a header using an encryption cache.
 *
 * # Safety
 */
int32_t h_encrypt_header_using_cache(int8_t *symmetric_key_ptr,
                                     int32_t *symmetric_key_len,
                                     int8_t *header_bytes_ptr,
                                     int32_t *header_bytes_len,
                                     int32_t cache_handle,
                                     const int8_t *encryption_policy_ptr,
                                     const int8_t *header_metadata_ptr,
                                     int32_t header_metadata_len,
                                     const int8_t *authentication_data_ptr,
                                     int32_t authentication_data_len);

/**
 * Encrypts a header without using an encryption cache.
 * It is slower but does not require destroying any cache when done.
 *
 * The symmetric key and header bytes are returned in the first OUT parameters
 * # Safety
 */
int32_t h_encrypt_header(int8_t *symmetric_key_ptr,
                         int32_t *symmetric_key_len,
                         int8_t *header_bytes_ptr,
                         int32_t *header_bytes_len,
                         const int8_t *policy_ptr,
                         int32_t policy_len,
                         const int8_t *mpk_ptr,
                         int32_t mpk_len,
                         const int8_t *encryption_policy_ptr,
                         const int8_t *header_metadata_ptr,
                         int32_t header_metadata_len,
                         const int8_t *authentication_data_ptr,
                         int32_t authentication_data_len);

/**
 * Creates a cache containing the user secret key. This cache can be reused
 * when decrypting messages which avoids passing this key to Rust in each call.
 *
 * Cf [`h_decrypt_header_using_cache()`](h_decrypt_header_using_cache).
 *
 * WARNING: [`h_destroy_decryption_cache()`](h_destroy_decryption_cache)
 * should be called to reclaim the cache memory.
 *
 * # Safety
 */
int32_t h_create_decryption_cache(int32_t *cache_handle, const int8_t *usk_ptr, int32_t usk_len);

/**
 * Reclaims decryption cache memory.
 *
 * # Safety
 */
int32_t h_destroy_decryption_cache(int32_t cache_handle);

/**
 * Decrypts an encrypted header using a cache. Returns the symmetric key and
 * header metadata if any.
 *
 * No header metadata is returned if `header_metadata_ptr` is `NULL`.
 *
 * # Safety
 */
int32_t h_decrypt_header_using_cache(int8_t *symmetric_key_ptr,
                                     int32_t *symmetric_key_len,
                                     int8_t *header_metadata_ptr,
                                     int32_t *header_metadata_len,
                                     const int8_t *encrypted_header_ptr,
                                     int32_t encrypted_header_len,
                                     const int8_t *authentication_data_ptr,
                                     int32_t authentication_data_len,
                                     int32_t cache_handle);

/**
 * Decrypts an encrypted header, returning the symmetric key and header
 * metadata if any.
 *
 * No header metadata is returned if `header_metadata_ptr` is `NULL`.
 *
 * # Safety
 */
int32_t h_decrypt_header(int8_t *symmetric_key_ptr,
                         int32_t *symmetric_key_len,
                         int8_t *header_metadata_ptr,
                         int32_t *header_metadata_len,
                         const int8_t *encrypted_header_ptr,
                         int32_t encrypted_header_len,
                         const int8_t *authentication_data_ptr,
                         int32_t authentication_data_len,
                         const int8_t *usk_ptr,
                         int32_t usk_len);

/**
 *
 * # Safety
 */
int32_t h_symmetric_encryption_overhead(void);

/**
 *
 * # Safety
 */
int32_t h_dem_encrypt(int8_t *ciphertext_ptr,
                      int32_t *ciphertext_len,
                      const int8_t *symmetric_key_ptr,
                      int32_t symmetric_key_len,
                      const int8_t *authentication_data_ptr,
                      int32_t authentication_data_len,
                      const int8_t *plaintext_ptr,
                      int32_t plaintext_len);

/**
 *
 * # Safety
 */
int32_t h_dem_decrypt(int8_t *plaintext_ptr,
                      int32_t *plaintext_len,
                      const int8_t *symmetric_key_ptr,
                      int32_t symmetric_key_len,
                      const int8_t *authentication_data_ptr,
                      int32_t authentication_data_len,
                      const int8_t *ciphertext_ptr,
                      int32_t ciphertext_len);

/**
 * Hybrid encrypt some content
 *
 * # Safety
 */
int32_t h_hybrid_encrypt(int8_t *ciphertext_ptr,
                         int32_t *ciphertext_len,
                         const int8_t *policy_ptr,
                         int32_t policy_len,
                         const int8_t *mpk_ptr,
                         int32_t mpk_len,
                         const int8_t *encryption_policy_ptr,
                         const int8_t *plaintext_ptr,
                         int32_t plaintext_len,
                         const int8_t *header_metadata_ptr,
                         int32_t header_metadata_len,
                         const int8_t *authentication_data_ptr,
                         int32_t authentication_data_len);

/**
 * Hybrid decrypt some content.
 *
 * No header metadata is returned if `header_metadata_ptr` is `NULL`.
 *
 * # Safety
 */
int32_t h_hybrid_decrypt(int8_t *plaintext_ptr,
                         int32_t *plaintext_len,
                         int8_t *header_metadata_ptr,
                         int32_t *header_metadata_len,
                         const int8_t *ciphertext_ptr,
                         int32_t ciphertext_len,
                         const int8_t *authentication_data_ptr,
                         int32_t authentication_data_len,
                         const int8_t *usk_ptr,
                         int32_t usk_len);

int32_t h_ecies_x25519_generate_key_pair(uint8_t *public_key_ptr,
                                         int32_t *public_key_len,
                                         uint8_t *private_key_ptr,
                                         int32_t *private_key_len);

int32_t h_ecies_salsa_seal_box_encrypt(uint8_t *output_ptr,
                                       int32_t *output_len,
                                       const int8_t *plaintext_ptr,
                                       int32_t plaintext_len,
                                       const int8_t *public_key_ptr,
                                       int32_t public_key_len,
                                       const int8_t *authentication_data_ptr,
                                       int32_t authentication_data_len);

uint32_t h_ecies_salsa_seal_box_get_encryption_overhead(void);

int32_t h_ecies_salsa_seal_box_decrypt(uint8_t *output_ptr,
                                       int32_t *output_len,
                                       const int8_t *ciphertext_ptr,
                                       int32_t ciphertext_len,
                                       const int8_t *private_key_ptr,
                                       int32_t private_key_len,
                                       const int8_t *authentication_data_ptr,
                                       int32_t authentication_data_len);

#if defined(DEFINE_WASM)
/**
 * Re-export the `cosmian_ffi` `h_get_error` function to clients with the old
 * `get_last_error` name The `h_get_error` is available inside the final lib
 * (but tools like `ffigen` seems to not parse it…) Maybe we can find a
 * solution by changing the function name inside the clients.
 *
 * # Safety
 *
 * It's unsafe.
 */
int32_t get_last_error(int8_t *error_ptr, int32_t *error_len);
#endif

#if defined(DEFINE_WASM)
/**
 * Recursively searches Findex graphs for values indexed by the given keywords.
 *
 * # Serialization
 *
 * Le output is serialized as follows:
 *
 * `LEB128(n_keywords) || LEB128(keyword_1)
 *     || keyword_1 || LEB128(n_associated_results)
 *     || LEB128(associated_result_1) || associated_result_1
 *     || ...`
 *
 * # Parameters
 *
 * - `search_results`          : (output) search result
 * - `key`                     : Findex key
 * - `label`                   : public information used to derive UIDs
 * - `keywords`                : serialized list of keywords
 * - `entry_table_number`      : number of different entry tables
 * - `interrupt`               : user interrupt called at each search iteration
 * - `fetch_entry_callback`    : callback used to fetch the Entry Table
 * - `fetch_chain_callback`    : callback used to fetch the Chain Table
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_search(uint8_t *search_results_ptr,
                 int32_t *search_results_len,
                 const uint8_t *key_ptr,
                 uint32_t key_len,
                 const uint8_t *label_ptr,
                 uint32_t label_len,
                 const uint8_t *keywords_ptr,
                 uint32_t keywords_len,
                 uint32_t entry_table_number,
                 Interrupt interrupt,
                 Fetch fetch_entry_callback,
                 Fetch fetch_chain_callback);
#endif

#if defined(DEFINE_WASM)
/**
 * Index the given values for the given keywords. After upserting, any
 * search for such a keyword will result in finding (at least) the
 * corresponding value.
 *
 * # Serialization
 *
 * The list of values to index for the associated keywords should be serialized
 * as follows:
 *
 * `LEB128(n_values) || serialized_value_1
 *     || LEB128(n_associated_keywords) || serialized_keyword_1 || ...`
 *
 * where values serialized as follows:
 *
 * `LEB128(value_bytes.len() + 1) || base64(prefix || value_bytes)`
 *
 * with `prefix` being `l` for a `Location` and `w` for a `NextKeyword`, and
 * where keywords are serialized as follows:
 *
 * `LEB128(keyword_bytes.len()) || base64(keyword_bytes)`
 *
 * The results are serialized as follows:
 *
 * `LEB128(n_values) || serialized_value_1 || ... || serialized_value_n`
 *
 * and `serialized_value_i` is serialized as follows:
 * `LEB128(keyword_bytes.len()) || keyword_bytes`
 *
 * # Parameters
 *
 * - `upsert_results`  : Returns the list of new keywords added to the index
 * - `key`      : Findex key
 * - `label`           : additional information used to derive Entry Table UIDs
 * TODO (TBZ): explain the serialization in the doc
 * - `additions`       : serialized list of new indexed values
 * - `deletions`       : serialized list of removed indexed values
 * - `entry_table_number` : number of different entry tables
 * - `fetch_entry`     : callback used to fetch the Entry Table
 * - `upsert_entry`    : callback used to upsert lines in the Entry Table
 * - `insert_chain`    : callback used to insert lines in the Chain Table
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_upsert(int8_t *upsert_results_ptr,
                 int32_t *upsert_results_len,
                 const uint8_t *key_ptr,
                 int32_t key_len,
                 const uint8_t *label_ptr,
                 int32_t label_len,
                 const int8_t *additions_ptr,
                 int32_t additions_len,
                 const int8_t *deletions_ptr,
                 int32_t deletions_len,
                 uint32_t entry_table_number,
                 Fetch fetch_entry,
                 Upsert upsert_entry,
                 Insert insert_chain);
#endif

#if defined(DEFINE_WASM)
/**
 * Replaces all the Index Entry Table UIDs and values. New UIDs are derived
 * using the given label and the KMAC key derived from the new key. The
 * values are decrypted using the DEM key derived from the key and
 * re-encrypted using the DEM key derived from the new key.
 *
 * Randomly selects index entries and recompact their associated chains. Chains
 * indexing no existing location are removed. Others are recomputed from a new
 * keying material. This removes unneeded paddings. New UIDs are derived for
 * the chain and values are re-encrypted using a DEM key derived from the new
 * keying material.
 *
 * # Parameters
 *
 * - `old_key`                         : old Findex key
 * - `new_key`                         : new Findex key
 * - `new_label`                       : public information used to derive UIDs
 * - `num_reindexing_before_full_set`  : number of compact operation needed to
 *   compact all the Chain Table
 * - `entry_table_number`               : number of different entry tables
 * - `fetch_entry`                     : callback used to fetch the Entry Table
 * - `fetch_chain`                     : callback used to fetch the Chain Table
 * - `update_lines`                    : callback used to update lines in both
 *   tables
 * - `list_removed_locations`          : callback used to list removed
 *   locations among the ones given
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_compact(const uint8_t *old_key_ptr,
                  int32_t old_key_len,
                  const uint8_t *new_key_ptr,
                  int32_t new_key_len,
                  const uint8_t *old_label_ptr,
                  int32_t old_label_len,
                  const uint8_t *new_label_ptr,
                  int32_t new_label_len,
                  uint32_t n_compact_to_full,
                  uint32_t entry_table_number,
                  Fetch fetch_entry,
                  Fetch fetch_chain,
                  Upsert upsert_entry,
                  Insert insert_chain,
                  Delete delete_entry,
                  Delete delete_chain,
                  DumpTokens dump_tokens_entry,
                  FilterObsoleteData filter_obsolete_data);
#endif

#if (defined(DEFINE_WASM) && defined(DEFINE_CLOUD))
/**
 * Recursively searches Findex graphs for values indexed by the given keywords.
 *
 * # Serialization
 *
 * Le output is serialized as follows:
 *
 * `LEB128(n_keywords) || LEB128(keyword_1)
 *     || keyword_1 || LEB128(n_associated_results)
 *     || LEB128(associated_result_1) || associated_result_1
 *     || ...`
 *
 * # Parameters
 *
 * - `search_results`          : (output) search result
 * - `token`                   : FindexREST token
 * - `label`                   : public information used to derive UIDs
 * - `keywords`                : `serde` serialized list of base64 keywords
 * - `base_url`                : FindexREST server URL (with http prefix and
 *   port if required). If null, use the default FindexREST server.
 * - `interrupt`               : user interrupt called at each search iteration
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_search_cloud(int8_t *search_results_ptr,
                       int32_t *search_results_len,
                       const int8_t *token_ptr,
                       const uint8_t *label_ptr,
                       int32_t label_len,
                       const uint8_t *keywords_ptr,
                       uint32_t keywords_len,
                       const int8_t *base_url_ptr,
                       Interrupt interrupt);
#endif

#if (defined(DEFINE_WASM) && defined(DEFINE_CLOUD))
/**
 * Index the given values for the given keywords. After upserting, any
 * search for such a keyword will result in finding (at least) the
 * corresponding value.
 *
 * # Serialization
 *
 * The list of values to index for the associated keywords should be serialized
 * as follows:
 *
 * `LEB128(n_values) || serialized_value_1
 *     || LEB128(n_associated_keywords) || serialized_keyword_1 || ...`
 *
 * where values serialized as follows:
 *
 * `LEB128(value_bytes.len() + 1) || base64(prefix || value_bytes)`
 *
 * with `prefix` being `l` for a `Location` and `w` for a `NextKeyword`, and
 * where keywords are serialized as follows:
 *
 * `LEB128(keyword_bytes.len()) || base64(keyword_bytes)`
 *
 * The results are serialized as follows:
 *
 * `LEB128(n_values) || serialized_value_1 || ... || serialized_value_n`
 *
 * and `serialized_value_i` is serialized as follows:
 * `LEB128(keyword_bytes.len()) || keyword_bytes`
 *
 * # Parameters
 *
 * - `upsert_results` : Returns the list of new keywords added to the index
 * - `token`          : FindexREST authorization token
 * - `label`          : additional information used to derive Entry Table UIDs
 * - `additions`      : serialized list of new indexed values
 * - `deletions`      : serialized list of removed indexed values
 * - `base_url`       : FindexREST server URL (with http prefix and port if
 *   required). If null, use the default FindexREST server.
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_upsert_cloud(int8_t *upsert_results_ptr,
                       int32_t *upsert_results_len,
                       const int8_t *token_ptr,
                       const uint8_t *label_ptr,
                       int32_t label_len,
                       const int8_t *additions_ptr,
                       int32_t additions_len,
                       const int8_t *deletions_ptr,
                       int32_t deletions_len,
                       const int8_t *base_url_ptr);
#endif

#if (defined(DEFINE_WASM) && defined(DEFINE_CLOUD))
/**
 * Generate a new Findex token from the provided index ID and signature seeds,
 * and a randomly generated Findex key inside Rust.
 *
 * The token is output inside `token_ptr`, `token_len` is updated to match the
 * token length (this length should always be the same, right now, the length
 * is always below 200 bytes)
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int32_t h_generate_new_token(uint8_t *token_ptr,
                             int32_t *token_len,
                             const int8_t *index_id_ptr,
                             const uint8_t *fetch_entries_seed_ptr,
                             int32_t fetch_entries_seed_len,
                             const uint8_t *fetch_chains_seed_ptr,
                             int32_t fetch_chains_seed_len,
                             const uint8_t *upsert_entries_seed_ptr,
                             int32_t upsert_entries_seed_len,
                             const uint8_t *insert_chains_seed_ptr,
                             int32_t insert_chains_seed_len);
#endif

/**
 * Encrypts a string using Format Preserving Encryption (FPE) algorithm with
 * the specified alphabet.
 *
 * # Safety
 *
 * This function is marked as `unsafe` due to the usage of raw pointers, which
 * need to be properly allocated and dereferenced by the caller.
 *
 * # Arguments
 *
 * * `plaintext_ptr` - a pointer to the buffer where the encrypted string will
 *   be written.
 * * `plaintext_len` - a pointer to the variable that stores the maximum size
 *   of the `plaintext_ptr` buffer. After the function call, the variable will
 *   be updated with the actual size of the encrypted string.
 * * `alphabet_id_ptr` - a pointer to a C string that represents the ID of the
 *   alphabet used for encryption.
 * * `input_ptr` - a pointer to a C string that represents the plaintext to be
 *   encrypted.
 * * `key_ptr` - a pointer to a C string that represents the key used for
 *   encryption.
 * * `key_len` - the length of the `key_ptr` string.
 * * `tweak_ptr` - a pointer to a C string that represents the tweak used for
 *   encryption.
 * * `tweak_len` - the length of the `tweak_ptr` string.
 * * `additional_characters_ptr` - a pointer to a C string that represents
 *   additional characters to be used in the alphabet.
 *
 * # Returns
 *
 * An integer that indicates whether the encryption was successful. A value of
 * `0` means success, while a non-zero value represents an error code.
 */
int32_t h_fpe_encrypt_alphabet(uint8_t *plaintext_ptr,
                               int32_t *plaintext_len,
                               const int8_t *alphabet_id_ptr,
                               const int8_t *input_ptr,
                               const int8_t *key_ptr,
                               int32_t key_len,
                               const int8_t *tweak_ptr,
                               int32_t tweak_len,
                               const int8_t *additional_characters_ptr);

/**
 * Decrypts a string using Format Preserving Encryption (FPE) algorithm with
 * the specified alphabet.
 *
 * # Safety
 *
 * This function is marked as `unsafe` due to the usage of raw pointers, which
 * need to be properly allocated and dereferenced by the caller.
 *
 * # Arguments
 *
 * * `ciphertext_ptr` - a pointer to the buffer where the encrypted string will
 *   be written.
 * * `ciphertext_len` - a pointer to the variable that stores the maximum size
 *   of the `ciphertext_ptr` buffer. After the function call, the variable will
 *   be updated with the actual size of the encrypted string.
 * * `alphabet_id_ptr` - a pointer to a C string that represents the ID of the
 *   alphabet used for encryption.
 * * `input_ptr` - a pointer to a C string that represents the plaintext to be
 *   encrypted.
 * * `key_ptr` - a pointer to a C string that represents the key used for
 *   encryption.
 * * `key_len` - the length of the `key_ptr` string.
 * * `tweak_ptr` - a pointer to a C string that represents the tweak used for
 *   encryption.
 * * `tweak_len` - the length of the `tweak_ptr` string.
 * * `additional_characters_ptr` - a pointer to a C string that represents
 *   additional characters to be used in the alphabet.
 *
 * # Returns
 *
 * An integer that indicates whether the encryption was successful. A value of
 * `0` means success, while a non-zero value represents an error code.
 */
int32_t h_fpe_decrypt_alphabet(uint8_t *ciphertext_ptr,
                               int32_t *ciphertext_len,
                               const int8_t *alphabet_id_ptr,
                               const int8_t *input_ptr,
                               const int8_t *key_ptr,
                               int32_t key_len,
                               const int8_t *tweak_ptr,
                               int32_t tweak_len,
                               const int8_t *additional_characters_ptr);

/**
 * Encrypts the input `f64` using the FPE algorithm with the given key and
 * tweak, and stores the result in the `output` pointer. The length of the key
 * and tweak must be specified in `key_len` and `tweak_len` respectively. The
 * function returns an `i32` indicating success (0) or failure (-1).
 *
 * # Safety
 *
 * This function is marked as `unsafe` because it accepts pointers to raw
 * memory.
 */
int32_t h_fpe_encrypt_float(double *output,
                            double input,
                            const int8_t *key_ptr,
                            int32_t key_len,
                            const int8_t *tweak_ptr,
                            int32_t tweak_len);

/**
 * Decrypts the input `f64` using the FPE algorithm with the given key and
 * tweak, and stores the result in the `output` pointer. The length of the key
 * and tweak must be specified in `key_len` and `tweak_len` respectively. The
 * function returns an `i32` indicating success (0) or failure (-1).
 *
 * # Safety
 *
 * This function is marked as `unsafe` because it accepts pointers to raw
 * memory.
 */
int32_t h_fpe_decrypt_float(double *output,
                            double input,
                            const int8_t *key_ptr,
                            int32_t key_len,
                            const int8_t *tweak_ptr,
                            int32_t tweak_len);

/**
 * Encrypts an integer using the format-preserving encryption (FPE) algorithm.
 *
 * # Safety
 *
 * This function is marked as `unsafe` because it takes raw pointers as input,
 * which must be valid and dereferenceable for the function to work correctly.
 *
 * # Arguments
 *
 * * `output`: A mutable pointer to the location where the encrypted output
 *   value will be stored.
 * * `input`: The integer value to be encrypted.
 * * `radix`: The radix of the numeric system being used.
 * * `digits`: The number of digits in the numeric system being used.
 * * `key_ptr`: A pointer to the key to be used for encryption.
 * * `key_len`: The length of the key in bytes.
 * * `tweak_ptr`: A pointer to the tweak value to be used for encryption.
 * * `tweak_len`: The length of the tweak in bytes.
 *
 * # Returns
 *
 * An integer value indicating whether the encryption was successful or not. A
 * return value of 0 indicates success, while any other value indicates an
 * error.
 */
int32_t h_fpe_encrypt_integer(uint64_t *output,
                              uint64_t input,
                              uint32_t radix,
                              uint32_t digits,
                              const int8_t *key_ptr,
                              int32_t key_len,
                              const int8_t *tweak_ptr,
                              int32_t tweak_len);

/**
 * Decrypts an integer using the format-preserving encryption (FPE) algorithm.
 *
 * # Safety
 *
 * This function is marked as `unsafe` because it takes raw pointers as input,
 * which must be valid and dereferenceable for the function to work correctly.
 *
 * # Arguments
 *
 * * `output`: A mutable pointer to the location where the encrypted output
 *   value will be stored.
 * * `input`: The integer value to be encrypted.
 * * `radix`: The radix of the numeric system being used.
 * * `digits`: The number of digits in the numeric system being used.
 * * `key_ptr`: A pointer to the key to be used for encryption.
 * * `key_len`: The length of the key in bytes.
 * * `tweak_ptr`: A pointer to the tweak value to be used for encryption.
 * * `tweak_len`: The length of the tweak in bytes.
 *
 * # Returns
 *
 * An integer value indicating whether the encryption was successful or not. A
 * return value of 0 indicates success, while any other value indicates an
 * error.
 */
int32_t h_fpe_decrypt_integer(uint64_t *output,
                              uint64_t input,
                              uint32_t radix,
                              uint32_t digits,
                              const int8_t *key_ptr,
                              int32_t key_len,
                              const int8_t *tweak_ptr,
                              int32_t tweak_len);

/**
 * Encrypts an input big integer using the FPE algorithm and returns the
 * encrypted value as an array of bytes.
 *
 * # Arguments
 *
 * * `output_ptr` - a pointer to the output buffer where the encrypted bytes
 *   will be written
 * * `output_len` - a pointer to an integer that will be updated with the
 *   length of the encrypted bytes
 * * `input_ptr` - a pointer to the input buffer that contains the big integer
 *   to be encrypted
 * * `radix` - the radix of the input big integer
 * * `digits` - the number of digits in the input big integer
 * * `key_ptr` - a pointer to the key buffer that will be used for encryption
 * * `key_len` - the length of the key buffer
 * * `tweak_ptr` - a pointer to the tweak buffer that will be used for
 *   encryption
 * * `tweak_len` - the length of the tweak buffer
 *
 * # Safety
 *
 * This function is marked unsafe because it operates on raw pointers and
 * performs unsafe memory operations.
 *
 * # Returns
 *
 * Returns 0 on success, -1 on error.
 */
int32_t h_fpe_encrypt_big_integer(uint8_t *output_ptr,
                                  int32_t *output_len,
                                  const int8_t *input_ptr,
                                  uint32_t radix,
                                  uint32_t digits,
                                  const int8_t *key_ptr,
                                  int32_t key_len,
                                  const int8_t *tweak_ptr,
                                  int32_t tweak_len);

/**
 * Decrypts an input big integer using the FPE algorithm and returns the
 * decrypted value as an array of bytes.
 *
 * # Arguments
 *
 * * `output_ptr` - a pointer to the output buffer where the decrypted bytes
 *   will be written
 * * `output_len` - a pointer to an integer that will be updated with the
 *   length of the decrypted bytes
 * * `input_ptr` - a pointer to the input buffer that contains the big integer
 *   to be decrypted
 * * `radix` - the radix of the input big integer
 * * `digits` - the number of digits in the input big integer
 * * `key_ptr` - a pointer to the key buffer that will be used for decryption
 * * `key_len` - the length of the key buffer
 * * `tweak_ptr` - a pointer to the tweak buffer that will be used for
 *   decryption
 * * `tweak_len` - the length of the tweak buffer
 *
 * # Safety
 *
 * This function is marked unsafe because it operates on raw pointers and
 * performs unsafe memory operations.
 *
 * # Returns
 *
 * Returns 0 on success, -1 on error.
 */
int32_t h_fpe_decrypt_big_integer(uint8_t *output_ptr,
                                  int32_t *output_len,
                                  const int8_t *input_ptr,
                                  uint32_t radix,
                                  uint32_t digits,
                                  const int8_t *key_ptr,
                                  int32_t key_len,
                                  const int8_t *tweak_ptr,
                                  int32_t tweak_len);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

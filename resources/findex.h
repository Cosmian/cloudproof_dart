// NOTE: Autogenerated file

/**
 * Number of bytes used to hash keywords.
 */
#define KeyWord_HASH_LENGTH 32

/**
 * Use a 256-bit `K`
 */
#define MASTER_KEY_LENGTH 32

/**
 * Use a 128-bit `K_wi`
 */
#define KWI_LENGTH 16

/**
 * Use a 128-bit `K_uid`
 * TODO TBZ: use 256 bits ?
 */
#define KMAC_KEY_LENGTH 16

/**
 * Callback to fetch the lines with the given UIDs from the Entry Table.
 * The values returned are encrypted since they are stored that way. The
 * decryption is performed by Findex.
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(uids.len()) || uid_1 || ...`
 *
 * The output should be serialized as follows:
 *
 * `LEB128(entries.len()) || LEB128(entry_1.len()) || entry_1 || ...`
 *
 * # Parameters
 *
 * - `entries` : (output) Entry Table items
 * - `uids`    : Entry Table UIDs of the lines to fetch
 */
typedef int (*FetchEntryTableCallback)(char *entries_ptr, unsigned int *entries_len, const unsigned char *uids_ptr, unsigned int uids_len);

/**
 * Upserts lines in the Entry Table. The input data should map each Entry
 * Table UID to upsert to the last value known by the client and the value
 * to upsert:
 *
 * `UID <-> (OLD_VALUE, NEW_VALUE)`
 *
 * To allow concurrent upsert operations, this callback should:
 *
 * 1 - for each UID given, perform an *atomic* conditional upsert: if the
 * current value stored in the DB is equal to `OLD_VALUE`, then `NEW_VALUE`
 * should be upserted;
 *
 * 2 - get the current values stored in the DB for all failed upserts from
 * step 1 and send them back to the client.
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * ` LEB128(entries.len()) || LEB128(old_value_1.len()) || old_value_1 ||
 * LEB128(new_value_1.len()) || new_value_1 || ...`
 *
 * The output should be serialized as follows:
 *
 * `LEB128(outputs.len()) || LEB128(output_1.len()) || output_1 || ...`
 *
 * # Parameters
 *
 * - `entries` : entries to be upserted
 * - `outputs` : (output) current value of the lines that failed to be upserted
 */
typedef void (*UpsertEntryTableCallback)(const unsigned char *entries_ptr, unsigned int entries_len, unsigned char *outputs_ptr, unsigned int *outputs_len);

/**
 * Inserts the given lines into the Chain Table. This should return an
 * error if a line with the same UID as one of the lines given already
 * exists.
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(chains.len()) || LEB128(chain_1.len() || chain_1 || ...`
 *
 * # Parameters
 *
 * - `chains`   : Chain Table items to insert
 */
typedef void (*InsertChainTableCallback)(const unsigned char *chains_ptr, unsigned int chains_len);

/**
 * Callback to return progress (partial results) during a search procedure.
 * Stops the search if the returned value is `false`. This can be useful to
 * stop prematurely the search when an intermediate result returned answers
 * the search.
 *
 * # Serialization
 *
 * The serialization of the intermediate results should follow:
 *
 * `LEB128(results.len()) || serialized_result_1 || ...`
 *
 * With the serialization of a result being:
 *
 * `prefix || byte_vector`
 *
 * where `prefix` is `l` (only `Location`s are returned) and the `byte_vector`
 * is the byte representation of the location.
 *
 * # Parameters
 *
 * - `intermediate_results` : search results (graph leaves are ignored)
 */
typedef bool (*ProgressCallback)(const unsigned char *intermediate_results_ptr, unsigned int intermediate_results_len);

/**
 * Callback to fetch the lines with the given UIDs from the Chain Table.
 * The values returned are encrypted since they are stored that way. The
 * decryption is performed by Findex.
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(uids.len()) || uid_1 || ...`
 *
 * The output should be serialized as follows:
 *
 * `LEB128(chains.len()) || LEB128(chain_1.len()) || chain_1 || ...`
 *
 * # Parameters
 *
 * - `chains`   : (output) Chain Table items
 * - `uids`    : Entry Table UIDs of the lines to fetch
 */
typedef int (*FetchChainTableCallback)(char *chains_ptr, unsigned int *chains_len, const unsigned char *uids_ptr, unsigned int uids_len);

/**
 *
 * # Return
 *
 * - 0: all done
 * - 1: ask again for more entries
 * - _: error
 */
typedef int (*FetchAllEntryTableCallback)(char *entries_ptr, unsigned int *entries_len, unsigned int number_of_entries);

typedef int (*UpdateLinesCallback)(const unsigned char *removed_chain_table_ids_ptr, unsigned int removed_chain_table_ids_len, const unsigned char *new_encrypted_entry_table_items_ptr, unsigned int new_encrypted_entry_table_items_len, const unsigned char *new_encrypted_chain_table_items_ptr, unsigned int new_encrypted_chain_table_items_len);

typedef int (*ListRemovedLocationsCallback)(char *removed_locations_ptr, unsigned int *removed_locations_len, const unsigned char *locations_ptr, unsigned int locations_len);

/**
 * Index the given values for the given keywords. After upserting, any
 * search for such a keyword will result in finding (at least) the
 * corresponding value.
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_upsert(const uint8_t *master_key_ptr,
             int master_key_len,
             const uint8_t *label_ptr,
             int label_len,
             const char *indexed_values_and_keywords_ptr,
             FetchEntryTableCallback fetch_entry,
             UpsertEntryTableCallback upsert_entry,
             InsertChainTableCallback upsert_chain);

/**
 * Recursively searches Findex graphs for values indexed by the given keywords.
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_search(char *indexed_values_ptr,
             int *indexed_values_len,
             const char *key_k_ptr,
             int key_k_len,
             const uint8_t *label_ptr,
             int label_len,
             const char *keywords_ptr,
             int loop_iteration_limit,
             int max_depth,
             ProgressCallback progress_callback,
             FetchEntryTableCallback fetch_entry,
             FetchChainTableCallback fetch_chain);

/**
 * Replaces all the Index Entry Table UIDs and values. New UIDs are derived
 * using the given label and the KMAC key derived from the new master key. The
 * values are dectypted using the DEM key derived from the master key and
 * re-encrypted using the DEM key derived from the new master key.
 *
 * Randomly selects index entries and recompact their associated chains. Chains
 * indexing no existing location are removed. Others are recomputed from a new
 * keying material. This removes unneeded paddings. New UIDs are derived for
 * the chain and values are re-encrypted using a DEM key derived from the new
 * keying material.
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_compact(int num_reindexing_before_full_set,
              const uint8_t *master_key_ptr,
              int master_key_len,
              const uint8_t *new_master_key_ptr,
              int new_master_key_len,
              const uint8_t *label_ptr,
              int label_len,
              FetchEntryTableCallback fetch_entry,
              FetchChainTableCallback fetch_chain,
              FetchAllEntryTableCallback fetch_all_entry,
              UpdateLinesCallback update_lines,
              ListRemovedLocationsCallback list_removed_locations);

/**
 * Get the most recent error as utf-8 bytes, clearing it in the process.
 * # Safety
 * - `error_msg`: must be pre-allocated with a sufficient size
 */
int get_last_error(char *error_msg_ptr, int *error_len);

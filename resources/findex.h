// NOTE: Autogenerated file

#define SECURE_FETCH_CHAINS_BATCH_SIZE 1

/**
 * Number of bytes used to hash keywords.
 */
#define Keyword_HASH_LENGTH 32

/**
 * Length of an index table UID in bytes.
 */
#define UID_LENGTH 32

/**
 * Length of the blocks in the Chain Table in bytes.
 */
#define BLOCK_LENGTH 32

/**
 * Number of blocks per Chain Table value.
 */
#define TABLE_WIDTH 5

/**
 * Length of the Findex master key in bytes.
 */
#define MASTER_KEY_LENGTH 16

/**
 * Length of the chain keying material (`K_wi`) in bytes.
 */
#define KWI_LENGTH 16

/**
 * Length of a KMAC key in bytes.
 */
#define KMAC_KEY_LENGTH 32

/**
 * Length of a DEM key in bytes.
 */
#define DEM_KEY_LENGTH 32

/**
 * Default number of results returned per keyword.
 */
#define MAX_RESULTS_PER_KEYWORD 65536

/**
 * Limit on the recursion to use when none is provided.
 */
#define MAX_DEPTH 100

/**
 * A pagination is performed in order to fetch the entire Entry Table. It is
 * fetched by batches of size [`NUMBER_OF_ENTRY_TABLE_LINE_IN_BATCH`].
 */
#define NUMBER_OF_ENTRY_TABLE_LINE_IN_BATCH 100

/**
 * See [`FindexCallbacks::progress()`](crate::core::FindexCallbacks::progress).
 *
 * # Serialization
 *
 * The intermediate results are serialized as follows:
 *
 * `LEB128(results.len()) || serialized_keyword_1
 *     || serialized_results_for_keyword_1`
 *
 * With the serialization of a keyword being:
 *
 * `LEB128(keyword.len()) || keyword`
 *
 * the serialization of the values associated to a keyword:
 *
 * `LEB128(serialized_results_for_keyword.len()) || serialized_result_1 || ...`
 *
 * and the serialization of a result:
 *
 * `LEB128(byte_vector.len() + 1) || prefix || byte_vector`
 *
 * where `prefix` is `l` (only `Location`s are returned) and the `byte_vector`
 * is the byte representation of the location.
 */
typedef bool (*ProgressCallback)(const unsigned char *intermediate_results_ptr, unsigned int intermediate_results_len);

/**
 * See [`FindexCallbacks::fetch_entry_table()`](crate::core::FindexCallbacks::fetch_entry_table).
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(n_uids) || UID_1 || ...`
 *
 * The output should be deserialized as follows:
 *
 * `LEB128(n_entries) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int (*FetchEntryTableCallback)(unsigned char *entries_ptr, unsigned int *entries_len, const unsigned char *uids_ptr, unsigned int uids_len);

/**
 * See [`FindexCallbacks::fetch_chain_table()`](crate::core::FindexCallbacks::fetch_chain_table).
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(n_uids) || UID_1 || ...`
 *
 * The output should be serialized as follows:
 *
 * `LEB128(n_lines) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int (*FetchChainTableCallback)(unsigned char *chains_ptr, unsigned int *chains_len, const unsigned char *uids_ptr, unsigned int uids_len);

/**
 * See [`FindexCallbacks::upsert_entry_table()`](crate::core::FindexCallbacks::upsert_entry_table).
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * ` LEB128(entries.len()) || UID_1
 *     || LEB128(old_value_1.len()) || old_value_1
 *     || LEB128(new_value_1.len()) || new_value_1
 *     || ...`
 *
 * The output should be serialized as follows:
 *
 * `LEB128(n_lines) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int (*UpsertEntryTableCallback)(unsigned char *outputs_ptr, unsigned int *outputs_len, const unsigned char *entries_ptr, unsigned int entries_len);

/**
 * See [`FindexCallbacks::insert_chain_table()`](crate::core::FindexCallbacks::insert_chain_table).
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(n_lines) || UID_1 || LEB128(value_1.len() || value_1 || ...`
 */
typedef int (*InsertChainTableCallback)(const unsigned char *chains_ptr, unsigned int chains_len);

/**
 * See [`FindexCallbacks::fetch_all_entry_table_uids()`](crate::core::FindexCallbacks::fetch_all_entry_table_uids).
 *
 * The output should be deserialized as follows:
 *
 * `UID_1 || UID_2 || ... || UID_n`
 */
typedef int (*FetchAllEntryTableUidsCallback)(unsigned char *uids_ptr, unsigned int *uids_len);

/**
 * See [`FindexCallbacks::update_lines()`](crate::core::FindexCallbacks::update_lines).
 *
 * # Serialization
 *
 * The removed Chain Table UIDs are serialized as follows:
 *
 * `LEB128(n_uids) || UID_1 || ...`
 *
 * The new table items are serialized as follows:
 *
 * `LEB128(n_items) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
 */
typedef int (*UpdateLinesCallback)(const unsigned char *chain_table_uids_to_remove_ptr, unsigned int chain_table_uids_to_remove_len, const unsigned char *new_encrypted_entry_table_items_ptr, unsigned int new_encrypted_entry_table_items_len, const unsigned char *new_encrypted_chain_table_items_ptr, unsigned int new_encrypted_chain_table_items_len);

/**
 * See
 * [`FindexCallbacks::list_removed_locations()`](crate::core::FindexCallbacks::list_removed_locations).
 *
 * # Serialization
 *
 * The input is serialized as follows:
 *
 * `LEB128(locations.len()) || LEB128(location_bytes_1.len()
 *     || location_bytes_1 || ...`
 *
 * Outputs should follow the same serialization.
 */
typedef int (*ListRemovedLocationsCallback)(unsigned char *removed_locations_ptr, unsigned int *removed_locations_len, const unsigned char *locations_ptr, unsigned int locations_len);

/**
 * Recursively searches Findex graphs for values indexed by the given keywords.
 *
 * # Serialization
 *
 * Le output is serialized as follows:
 *
 * `LEB128(n_keywords) || LEB128(keyword_1)
 *     || keyword_1 || LEB128(n_associated_results)
 *     || LEB128(associated_result_1) || associated_result_1
 *     || ...`
 *
 * # Parameters
 *
 * - `indexed_values`          : (output) search result
 * - `master_key`              : masterkey
 * - `label`                   : additional information used to derive Entry
 *   Table UIDs
 * - `keywords`                : `serde` serialized list of base64 keywords
 * - `max_results_per_keyword` : maximum number of results returned per keyword
 * - `max_depth`               : maximum recursion depth allowed
 * - `progress_callback`       : callback used to retrieve intermediate results
 *   and transmit user interrupt
 * - `fetch_entry`             : callback used to fetch the Entry Table
 * - `fetch_chain`             : callback used to fetch the Chain Table
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_search(char *indexed_values_ptr,
             int *indexed_values_len,
             const char *master_key_ptr,
             int master_key_len,
             const uint8_t *label_ptr,
             int label_len,
             const char *keywords_ptr,
             int max_results_per_keyword,
             int max_depth,
             int fetch_chains_batch_size,
             ProgressCallback progress_callback,
             FetchEntryTableCallback fetch_entry,
             FetchChainTableCallback fetch_chain);

/**
 * Index the given values for the given keywords. After upserting, any
 * search for such a keyword will result in finding (at least) the
 * corresponding value.
 *
 * # Serialization
 *
 * The list of values to index for the associated keywords should be serialized
 * as follows:
 *
 * `LEB128(n_values) || serialized_value_1
 *     || LEB128(n_associated_keywords) || serialized_keyword_1 || ...`
 *
 * where values serialized as follows:
 *
 * `LEB128(value_bytes.len() + 1) || base64(prefix || value_bytes)`
 *
 * with `prefix` being `l` for a `Location` and `w` for a `NextKeyword`, and
 * where keywords are serialized as follows:
 *
 * `LEB128(keyword_bytes.len()) || base64(keyword_bytes)`
 *
 * # Parameters
 *
 * - `master_key`      : Findex master key
 * - `label`           : additional information used to derive Entry Table UIDs
 * - `indexed_values_and_keywords` : serialized list of values and the keywords
 *   used to index them
 * - `fetch_entry`     : callback used to fetch the Entry Table
 * - `upsert_entry`    : callback used to upsert lines in the Entry Table
 * - `insert_chain`    : callback used to insert lines in the Chain Table
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_upsert(const uint8_t *master_key_ptr,
             int master_key_len,
             const uint8_t *label_ptr,
             int label_len,
             const char *indexed_values_and_keywords_ptr,
             FetchEntryTableCallback fetch_entry,
             UpsertEntryTableCallback upsert_entry,
             InsertChainTableCallback insert_chain);

/**
 * Replaces all the Index Entry Table UIDs and values. New UIDs are derived
 * using the given label and the KMAC key derived from the new master key. The
 * values are dectypted using the DEM key derived from the master key and
 * re-encrypted using the DEM key derived from the new master key.
 *
 * Randomly selects index entries and recompact their associated chains. Chains
 * indexing no existing location are removed. Others are recomputed from a new
 * keying material. This removes unneeded paddings. New UIDs are derived for
 * the chain and values are re-encrypted using a DEM key derived from the new
 * keying material.
 *
 * # Parameters
 *
 * - `num_reindexing_before_full_set`  : number of compact operation needed to
 *   compact all Chain Table
 * - `old_master_key`                  : old Findex master key
 * - `new_master_key`                  : new Findex master key
 * - `label`                           : additional information used to derive
 *   Entry Table UIDs
 * - `fetch_entry`                     : callback used to fetch the Entry Table
 * - `fetch_chain`                     : callback used to fetch the Chain Table
 * - `update_lines`                    : callback used to update lines in both
 *   tables
 * - `list_removed_locations`          : callback used to list removed
 *   locations among the ones given
 *
 * # Safety
 *
 * Cannot be safe since using FFI.
 */
int h_compact(int num_reindexing_before_full_set,
              const uint8_t *master_key_ptr,
              int master_key_len,
              const uint8_t *new_master_key_ptr,
              int new_master_key_len,
              const uint8_t *label_ptr,
              int label_len,
              FetchAllEntryTableUidsCallback fetch_all_entry_table_uids,
              FetchEntryTableCallback fetch_entry,
              FetchChainTableCallback fetch_chain,
              UpdateLinesCallback update_lines,
              ListRemovedLocationsCallback list_removed_locations);

/**
 * Get the most recent error as utf-8 bytes, clearing it in the process.
 * # Safety
 * - `error_msg`: must be pre-allocated with a sufficient size
 */
int get_last_error(char *error_msg_ptr, int *error_len);

// ignore_for_file: avoid_print

import 'dart:ffi';
import 'dart:typed_data';

import 'package:cloudproof/cloudproof.dart';
import 'package:flutter_test/flutter_test.dart';

import 'in_memory_users.dart';

const expectedUsersIdsForFrance = [
  4,
  5,
  7,
  8,
  14,
  17,
  19,
  20,
  23,
  34,
  37,
  43,
  46,
  48,
  55,
  56,
  60,
  61,
  63,
  65,
  68,
  70,
  71,
  77,
  80,
  82,
  83,
  85,
  86,
  96
];

class InMemoryFindex {
  static Map<Uint8List, Uint8List>? entryTable;
  static Map<Uint8List, Uint8List>? chainTable;

  static void init() {
    entryTable = {};
    chainTable = {};
  }

  /// Naive [List] equality implementation.
  static bool listEquals<E>(List<E> list1, List<E> list2) {
    if (identical(list1, list2)) {
      return true;
    }

    if (list1.length != list2.length) {
      return false;
    }

    for (var i = 0; i < list1.length; i += 1) {
      if (list1[i] != list2[i]) {
        return false;
      }
    }

    return true;
  }

  static Future<void> indexAll(
      FindexMasterKey masterKey, Uint8List label) async {
    final indexedValuesAndKeywords = {
      for (final user in Users.getUsers())
        IndexedValue.fromLocation(user.location): user.indexedWords,
    };

    await upsert(masterKey, label, indexedValuesAndKeywords);
  }

  static List<UidAndValue> fetchEntries(Uids uids) {
    List<UidAndValue> entries = [];

    if (entryTable != null) {
      entryTable!.forEach((key, value) {
        for (Uint8List uid in uids.uids) {
          if (listEquals(uid, key)) {
            // print('fetchEntries: Key: $key, Value: $value');
            entries.add(UidAndValue(key, value));
            break;
          }
        }
      });
    }

    return entries;
  }

  static List<UidAndValue> fetchChains(Uids uids) {
    List<UidAndValue> chains = [];

    if (chainTable != null) {
      chainTable!.forEach((key, value) {
        for (Uint8List uid in uids.uids) {
          if (listEquals(uid, key)) {
            // print('fetchChains: Key: $key, Value: $value');
            chains.add(UidAndValue(uid, value));
            break;
          }
        }
      });
    }

    return chains;
  }

  static void upsertEntry(UpsertData entry) {
    if (entryTable != null) {
      entryTable?[entry.uid] = entry.newValue;
    }
  }

  static List<UidAndValue> upsertEntries(List<UpsertData> entries) {
    List<UidAndValue> rejected = [];
    for (UpsertData entry in entries) {
      if (entryTable != null) {
        entryTable?[entry.uid] = entry.newValue;
      }
    }
    return rejected;
  }

  static void insertChains(List<UidAndValue> chains) {
    for (UidAndValue chain in chains) {
      if (chainTable != null) {
        chainTable?[chain.uid] = chain.value;
      }
    }
  }

  // --------------------------------------------------
  // Copy-paste code :AutoGeneratedImplementation
  // --------------------------------------------------

  static Future<Map<Keyword, List<IndexedValue>>> search(
    Uint8List keyK,
    Uint8List label,
    List<Keyword> words,
  ) async {
    return await Findex.search(
      keyK,
      label,
      words,
      Pointer.fromFunction(
        fetchEntriesCallback,
        errorCodeInCaseOfCallbackException,
      ),
      Pointer.fromFunction(
        fetchChainsCallback,
        errorCodeInCaseOfCallbackException,
      ),
    );
  }

  static Future<void> upsert(
    FindexMasterKey masterKey,
    Uint8List label,
    Map<IndexedValue, List<Keyword>> indexedValuesAndKeywords,
  ) async {
    await Findex.upsert(
      masterKey,
      label,
      indexedValuesAndKeywords,
      Pointer.fromFunction(
        fetchEntriesCallback,
        errorCodeInCaseOfCallbackException,
      ),
      Pointer.fromFunction(
        upsertEntriesCallback,
        errorCodeInCaseOfCallbackException,
      ),
      Pointer.fromFunction(
        insertChainsCallback,
        errorCodeInCaseOfCallbackException,
      ),
    );
  }

  static int fetchEntriesCallback(
    Pointer<UnsignedChar> outputEntryTableLinesPointer,
    Pointer<UnsignedInt> outputEntryTableLinesLength,
    Pointer<UnsignedChar> uidsPointer,
    int uidsNumber,
  ) {
    return Findex.wrapSyncFetchCallback(
      InMemoryFindex.fetchEntries,
      outputEntryTableLinesPointer,
      outputEntryTableLinesLength,
      uidsPointer,
      uidsNumber,
    );
  }

  static int fetchChainsCallback(
    Pointer<UnsignedChar> outputChainTableLinesPointer,
    Pointer<UnsignedInt> outputChainTableLinesLength,
    Pointer<UnsignedChar> uidsPointer,
    int uidsNumber,
  ) {
    return Findex.wrapSyncFetchCallback(
      InMemoryFindex.fetchChains,
      outputChainTableLinesPointer,
      outputChainTableLinesLength,
      uidsPointer,
      uidsNumber,
    );
  }

  static int upsertEntriesCallback(
    Pointer<UnsignedChar> outputRejectedEntriesListPointer,
    Pointer<UnsignedInt> outputRejectedEntriesListLength,
    Pointer<UnsignedChar> entriesListPointer,
    int entriesListLength,
  ) {
    return Findex.wrapSyncUpsertEntriesCallback(
      InMemoryFindex.upsertEntries,
      outputRejectedEntriesListPointer,
      outputRejectedEntriesListLength,
      entriesListPointer,
      entriesListLength,
    );
  }

  static int insertChainsCallback(
    Pointer<UnsignedChar> chainsListPointer,
    int chainsListLength,
  ) {
    return Findex.wrapSyncInsertChainsCallback(
      InMemoryFindex.insertChains,
      chainsListPointer,
      chainsListLength,
    );
  }
}

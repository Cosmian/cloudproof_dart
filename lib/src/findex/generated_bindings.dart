// ignore_for_file: constant_identifier_names, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Dart bindings to call Findex functions
class FindexNativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  FindexNativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  FindexNativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Recursively searches Findex graphs for values indexed by the given keywords.
  ///
  /// # Serialization
  ///
  /// Le output is serialized as follows:
  ///
  /// `LEB128(n_keywords) || LEB128(keyword_1)
  /// || keyword_1 || LEB128(n_associated_results)
  /// || LEB128(associated_result_1) || associated_result_1
  /// || ...`
  ///
  /// # Parameters
  ///
  /// - `indexed_values`          : (output) search result
  /// - `master_key`              : masterkey
  /// - `label`                   : additional information used to derive Entry
  /// Table UIDs
  /// - `keywords`                : `serde` serialized list of base64 keywords
  /// - `max_results_per_keyword` : maximum number of results returned per keyword
  /// - `max_depth`               : maximum recursion depth allowed
  /// - `progress_callback`       : callback used to retrieve intermediate results
  /// and transmit user interrupt
  /// - `fetch_entry`             : callback used to fetch the Entry Table
  /// - `fetch_chain`             : callback used to fetch the Chain Table
  ///
  /// # Safety
  ///
  /// Cannot be safe since using FFI.
  int h_search(
    ffi.Pointer<ffi.Char> indexed_values_ptr,
    ffi.Pointer<ffi.Int> indexed_values_len,
    ffi.Pointer<ffi.Char> master_key_ptr,
    int master_key_len,
    ffi.Pointer<ffi.Int> label_ptr,
    int label_len,
    ffi.Pointer<ffi.Char> keywords_ptr,
    int max_results_per_keyword,
    int max_depth,
    int fetch_chains_batch_size,
    int progress_callback,
    FetchEntryTableCallback fetch_entry,
    FetchChainTableCallback fetch_chain,
  ) {
    return _h_search(
      indexed_values_ptr,
      indexed_values_len,
      master_key_ptr,
      master_key_len,
      label_ptr,
      label_len,
      keywords_ptr,
      max_results_per_keyword,
      max_depth,
      fetch_chains_batch_size,
      progress_callback,
      fetch_entry,
      fetch_chain,
    );
  }

  late final _h_searchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              ffi.Int,
              FetchEntryTableCallback,
              FetchChainTableCallback)>>('h_search');
  late final _h_search = _h_searchPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          int,
          int,
          FetchEntryTableCallback,
          FetchChainTableCallback)>();

  /// Index the given values for the given keywords. After upserting, any
  /// search for such a keyword will result in finding (at least) the
  /// corresponding value.
  ///
  /// # Serialization
  ///
  /// The list of values to index for the associated keywords should be serialized
  /// as follows:
  ///
  /// `LEB128(n_values) || serialized_value_1
  /// || LEB128(n_associated_keywords) || serialized_keyword_1 || ...`
  ///
  /// where values serialized as follows:
  ///
  /// `LEB128(value_bytes.len() + 1) || base64(prefix || value_bytes)`
  ///
  /// with `prefix` being `l` for a `Location` and `w` for a `NextKeyword`, and
  /// where keywords are serialized as follows:
  ///
  /// `LEB128(keyword_bytes.len()) || base64(keyword_bytes)`
  ///
  /// # Parameters
  ///
  /// - `master_key`      : Findex master key
  /// - `label`           : additional information used to derive Entry Table UIDs
  /// - `indexed_values_and_keywords` : serialized list of values and the keywords
  /// used to index them
  /// - `fetch_entry`     : callback used to fetch the Entry Table
  /// - `upsert_entry`    : callback used to upsert lines in the Entry Table
  /// - `insert_chain`    : callback used to insert lines in the Chain Table
  ///
  /// # Safety
  ///
  /// Cannot be safe since using FFI.
  int h_upsert(
    ffi.Pointer<ffi.Int> master_key_ptr,
    int master_key_len,
    ffi.Pointer<ffi.Int> label_ptr,
    int label_len,
    ffi.Pointer<ffi.Char> indexed_values_and_keywords_ptr,
    FetchEntryTableCallback fetch_entry,
    UpsertEntryTableCallback upsert_entry,
    InsertChainTableCallback insert_chain,
  ) {
    return _h_upsert(
      master_key_ptr,
      master_key_len,
      label_ptr,
      label_len,
      indexed_values_and_keywords_ptr,
      fetch_entry,
      upsert_entry,
      insert_chain,
    );
  }

  late final _h_upsertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              FetchEntryTableCallback,
              UpsertEntryTableCallback,
              InsertChainTableCallback)>>('h_upsert');
  late final _h_upsert = _h_upsertPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Char>,
          FetchEntryTableCallback,
          UpsertEntryTableCallback,
          InsertChainTableCallback)>();

  /// Replaces all the Index Entry Table UIDs and values. New UIDs are derived
  /// using the given label and the KMAC key derived from the new master key. The
  /// values are dectypted using the DEM key derived from the master key and
  /// re-encrypted using the DEM key derived from the new master key.
  ///
  /// Randomly selects index entries and recompact their associated chains. Chains
  /// indexing no existing location are removed. Others are recomputed from a new
  /// keying material. This removes unneeded paddings. New UIDs are derived for
  /// the chain and values are re-encrypted using a DEM key derived from the new
  /// keying material.
  ///
  /// # Parameters
  ///
  /// - `num_reindexing_before_full_set`  : number of compact operation needed to
  /// compact all Chain Table
  /// - `old_master_key`                  : old Findex master key
  /// - `new_master_key`                  : new Findex master key
  /// - `label`                           : additional information used to derive
  /// Entry Table UIDs
  /// - `fetch_entry`                     : callback used to fetch the Entry Table
  /// - `fetch_chain`                     : callback used to fetch the Chain Table
  /// - `update_lines`                    : callback used to update lines in both
  /// tables
  /// - `list_removed_locations`          : callback used to list removed
  /// locations among the ones given
  ///
  /// # Safety
  ///
  /// Cannot be safe since using FFI.
  int h_compact(
    int num_reindexing_before_full_set,
    ffi.Pointer<ffi.Int> master_key_ptr,
    int master_key_len,
    ffi.Pointer<ffi.Int> new_master_key_ptr,
    int new_master_key_len,
    ffi.Pointer<ffi.Int> label_ptr,
    int label_len,
    FetchAllEntryTableUidsCallback fetch_all_entry_table_uids,
    FetchEntryTableCallback fetch_entry,
    FetchChainTableCallback fetch_chain,
    UpdateLinesCallback update_lines,
    ListRemovedLocationsCallback list_removed_locations,
  ) {
    return _h_compact(
      num_reindexing_before_full_set,
      master_key_ptr,
      master_key_len,
      new_master_key_ptr,
      new_master_key_len,
      label_ptr,
      label_len,
      fetch_all_entry_table_uids,
      fetch_entry,
      fetch_chain,
      update_lines,
      list_removed_locations,
    );
  }

  late final _h_compactPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              FetchAllEntryTableUidsCallback,
              FetchEntryTableCallback,
              FetchChainTableCallback,
              UpdateLinesCallback,
              ListRemovedLocationsCallback)>>('h_compact');
  late final _h_compact = _h_compactPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          ffi.Pointer<ffi.Int>,
          int,
          FetchAllEntryTableUidsCallback,
          FetchEntryTableCallback,
          FetchChainTableCallback,
          UpdateLinesCallback,
          ListRemovedLocationsCallback)>();

  /// Get the most recent error as utf-8 bytes, clearing it in the process.
  /// # Safety
  /// - `error_msg`: must be pre-allocated with a sufficient size
  int get_last_error(
    ffi.Pointer<ffi.Char> error_msg_ptr,
    ffi.Pointer<ffi.Int> error_len,
  ) {
    return _get_last_error(
      error_msg_ptr,
      error_len,
    );
  }

  late final _get_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>>('get_last_error');
  late final _get_last_error = _get_last_errorPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();
}

/// See [`FindexCallbacks::fetch_entry_table()`](crate::core::FindexCallbacks::fetch_entry_table).
///
/// # Serialization
///
/// The input is serialized as follows:
///
/// `LEB128(n_uids) || UID_1 || ...`
///
/// The output should be deserialized as follows:
///
/// `LEB128(n_entries) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
typedef FetchEntryTableCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Pointer<ffi.UnsignedInt>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt)>>;

/// See [`FindexCallbacks::fetch_chain_table()`](crate::core::FindexCallbacks::fetch_chain_table).
///
/// # Serialization
///
/// The input is serialized as follows:
///
/// `LEB128(n_uids) || UID_1 || ...`
///
/// The output should be serialized as follows:
///
/// `LEB128(n_lines) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
typedef FetchChainTableCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Pointer<ffi.UnsignedInt>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt)>>;

/// See [`FindexCallbacks::upsert_entry_table()`](crate::core::FindexCallbacks::upsert_entry_table).
///
/// # Serialization
///
/// The input is serialized as follows:
///
/// ` LEB128(entries.len()) || UID_1
/// || LEB128(old_value_1.len()) || old_value_1
/// || LEB128(new_value_1.len()) || new_value_1
/// || ...`
///
/// The output should be serialized as follows:
///
/// `LEB128(n_lines) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
typedef UpsertEntryTableCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Pointer<ffi.UnsignedInt>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt)>>;

/// See [`FindexCallbacks::insert_chain_table()`](crate::core::FindexCallbacks::insert_chain_table).
///
/// # Serialization
///
/// The input is serialized as follows:
///
/// `LEB128(n_lines) || UID_1 || LEB128(value_1.len() || value_1 || ...`
typedef InsertChainTableCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>;

/// See [`FindexCallbacks::fetch_all_entry_table_uids()`](crate::core::FindexCallbacks::fetch_all_entry_table_uids).
///
/// The output should be deserialized as follows:
///
/// `UID_1 || UID_2 || ... || UID_n`
typedef FetchAllEntryTableUidsCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>, ffi.Pointer<ffi.UnsignedInt>)>>;

/// See [`FindexCallbacks::update_lines()`](crate::core::FindexCallbacks::update_lines).
///
/// # Serialization
///
/// The removed Chain Table UIDs are serialized as follows:
///
/// `LEB128(n_uids) || UID_1 || ...`
///
/// The new table items are serialized as follows:
///
/// `LEB128(n_items) || UID_1 || LEB128(value_1.len()) || value_1 || ...`
typedef UpdateLinesCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt)>>;

/// See
/// [`FindexCallbacks::list_removed_locations()`](crate::core::FindexCallbacks::list_removed_locations).
///
/// # Serialization
///
/// The input is serialized as follows:
///
/// `LEB128(locations.len()) || LEB128(location_bytes_1.len()
/// || location_bytes_1 || ...`
///
/// Outputs should follow the same serialization.
typedef ListRemovedLocationsCallback = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Pointer<ffi.UnsignedInt>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.UnsignedInt)>>;

const int Keyword_HASH_LENGTH = 32;

const int UID_LENGTH = 32;

const int BLOCK_LENGTH = 32;

const int TABLE_WIDTH = 5;

const int MASTER_KEY_LENGTH = 16;

const int KWI_LENGTH = 16;

const int KMAC_KEY_LENGTH = 32;

const int DEM_KEY_LENGTH = 32;

const int MAX_RESULTS_PER_KEYWORD = 65536;

const int MAX_DEPTH = 100;

const int NUMBER_OF_ENTRY_TABLE_LINE_IN_BATCH = 100;

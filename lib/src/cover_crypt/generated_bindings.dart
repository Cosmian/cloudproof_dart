// ignore_for_file: constant_identifier_names, non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Externally set the last error recorded on the Rust side
  ///
  /// # Safety
  /// This function is meant to be called from the Foreign Function
  /// Interface
  int set_error(
    ffi.Pointer<ffi.Char> error_message_ptr,
  ) {
    return _set_error(
      error_message_ptr,
    );
  }

  late final _set_errorPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'set_error');
  late final _set_error =
      _set_errorPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Get the most recent error as utf-8 bytes, clearing it in the process.
  /// # Safety
  /// - `error_msg`: must be pre-allocated with a sufficient size
  int get_last_error(
    ffi.Pointer<ffi.Char> error_msg_ptr,
    ffi.Pointer<ffi.Int> error_len,
  ) {
    return _get_last_error(
      error_msg_ptr,
      error_len,
    );
  }

  late final _get_last_errorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>>('get_last_error');
  late final _get_last_error = _get_last_errorPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>)>();

  /// Generate the master authority keys for supplied Policy
  ///
  /// - `master_keys_ptr`    : Output buffer containing both master keys
  /// - `master_keys_len`    : Size of the output buffer
  /// - `policy_ptr`         : Policy to use to generate the keys
  /// # Safety
  int h_generate_master_keys(
    ffi.Pointer<ffi.Char> master_keys_ptr,
    ffi.Pointer<ffi.Int> master_keys_len,
    ffi.Pointer<ffi.Char> policy_ptr,
  ) {
    return _h_generate_master_keys(
      master_keys_ptr,
      master_keys_len,
      policy_ptr,
    );
  }

  late final _h_generate_master_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('h_generate_master_keys');
  late final _h_generate_master_keys = _h_generate_master_keysPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>)>();

  /// Generate the user private key matching the given access policy
  ///
  /// - `user_private_key_ptr`: Output buffer containing user private key
  /// - `user_private_key_len`: Size of the output buffer
  /// - `master_private_key_ptr`: Master private key (required for this
  /// generation)
  /// - `master_private_key_len`: Master private key length
  /// - `access_policy_ptr`: Access policy of the user private key (JSON)
  /// - `policy_ptr`: Policy to use to generate the keys (JSON)
  /// # Safety
  int h_generate_user_private_key(
    ffi.Pointer<ffi.Char> user_private_key_ptr,
    ffi.Pointer<ffi.Int> user_private_key_len,
    ffi.Pointer<ffi.Char> master_private_key_ptr,
    int master_private_key_len,
    ffi.Pointer<ffi.Char> access_policy_ptr,
    ffi.Pointer<ffi.Char> policy_ptr,
  ) {
    return _h_generate_user_private_key(
      user_private_key_ptr,
      user_private_key_len,
      master_private_key_ptr,
      master_private_key_len,
      access_policy_ptr,
      policy_ptr,
    );
  }

  late final _h_generate_user_private_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('h_generate_user_private_key');
  late final _h_generate_user_private_key =
      _h_generate_user_private_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Rotate the attributes of the given policy
  ///
  /// - `updated_policy_ptr`: Output buffer containing new policy
  /// - `updated_policy_len`: Size of the output buffer
  /// - `attributes_ptr`: Attributes to rotate (JSON)
  /// - `policy_ptr`: Policy to use to generate the keys (JSON)
  /// # Safety
  int h_rotate_attributes(
    ffi.Pointer<ffi.Char> updated_policy_ptr,
    ffi.Pointer<ffi.Int> updated_policy_len,
    ffi.Pointer<ffi.Char> attributes_ptr,
    ffi.Pointer<ffi.Char> policy_ptr,
  ) {
    return _h_rotate_attributes(
      updated_policy_ptr,
      updated_policy_len,
      attributes_ptr,
      policy_ptr,
    );
  }

  late final _h_rotate_attributesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('h_rotate_attributes');
  late final _h_rotate_attributes = _h_rotate_attributesPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Update the master keys according to this new policy.
  ///
  /// When a partition exists in the new policy but not in the master keys,
  /// a new keypair is added to the master keys for that partition.
  /// When a partition exists on the master keys, but not in the new policy,
  /// it is removed from the master keys.
  ///
  /// - `updated_master_private_key_ptr`: Output buffer containing the updated master private key
  /// - `updated_master_private_key_len`: Size of the updated master private key output buffer
  /// - `updated_master_public_key_ptr`: Output buffer containing the updated master public key
  /// - `updated_master_public_key_len`: Size of the updated master public key output buffer
  /// - `current_master_private_key_ptr`: current master private key
  /// - `current_master_private_key_len`: current master private key length
  /// - `current_master_public_key_ptr`: current master public key
  /// - `current_master_public_key_len`: current master public key length
  /// - `policy_ptr`: Policy to use to update the master keys (JSON)
  /// # Safety
  int h_update_master_keys(
    ffi.Pointer<ffi.Char> updated_master_private_key_ptr,
    ffi.Pointer<ffi.Int> updated_master_private_key_len,
    ffi.Pointer<ffi.Char> updated_master_public_key_ptr,
    ffi.Pointer<ffi.Int> updated_master_public_key_len,
    ffi.Pointer<ffi.Char> current_master_private_key_ptr,
    int current_master_private_key_len,
    ffi.Pointer<ffi.Char> current_master_public_key_ptr,
    int current_master_public_key_len,
    ffi.Pointer<ffi.Char> policy_ptr,
  ) {
    return _h_update_master_keys(
      updated_master_private_key_ptr,
      updated_master_private_key_len,
      updated_master_public_key_ptr,
      updated_master_public_key_len,
      current_master_private_key_ptr,
      current_master_private_key_len,
      current_master_public_key_ptr,
      current_master_public_key_len,
      policy_ptr,
    );
  }

  late final _h_update_master_keysPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('h_update_master_keys');
  late final _h_update_master_keys = _h_update_master_keysPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Refresh the user key according to the given master key and access policy.
  ///
  /// The user key will be granted access to the current partitions, as determined by its access policy.
  /// If preserve_old_partitions is set, the user access to rotated partitions will be preserved
  ///
  /// - `updated_user_private_key_ptr`: Output buffer containing the updated user private key
  /// - `updated_user_private_key_len`: Size of the updated user private key output buffer
  /// - `master_private_key_ptr`: master private key
  /// - `master_private_key_len`: master private key length
  /// - `current_user_private_key_ptr`: current user private key
  /// - `current_user_private_key_len`: current user private key length
  /// - `access_policy_ptr`: Access policy of the user private key (JSON)
  /// - `policy_ptr`: Policy to use to update the master keys (JSON)
  /// - `preserve_old_partitions_access`: set to 1 to preserve the user access to the rotated partitions
  /// # Safety
  int h_refresh_user_private_key(
    ffi.Pointer<ffi.Char> updated_user_private_key_ptr,
    ffi.Pointer<ffi.Int> updated_user_private_key_len,
    ffi.Pointer<ffi.Char> master_private_key_ptr,
    int master_private_key_len,
    ffi.Pointer<ffi.Char> current_user_private_key_ptr,
    int current_user_private_key_len,
    ffi.Pointer<ffi.Char> access_policy_ptr,
    ffi.Pointer<ffi.Char> policy_ptr,
    int preserve_old_partitions_access,
  ) {
    return _h_refresh_user_private_key(
      updated_user_private_key_ptr,
      updated_user_private_key_len,
      master_private_key_ptr,
      master_private_key_len,
      current_user_private_key_ptr,
      current_user_private_key_len,
      access_policy_ptr,
      policy_ptr,
      preserve_old_partitions_access,
    );
  }

  late final _h_refresh_user_private_keyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_refresh_user_private_key');
  late final _h_refresh_user_private_key =
      _h_refresh_user_private_keyPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int)>();

  /// Create a cache of the Public Key and Policy which can be re-used
  /// when encrypting multiple messages. This avoids having to re-instantiate
  /// the public key on the Rust side on every encryption which is costly.
  ///
  /// This method is to be used in conjunction with
  /// h_aes_encrypt_header_using_cache
  ///
  /// WARN: h_aes_destroy_encrypt_cache() should be called
  /// to reclaim the memory of the cache when done
  /// # Safety
  int h_aes_create_encryption_cache(
    ffi.Pointer<ffi.Int> cache_handle,
    ffi.Pointer<ffi.Char> policy_ptr,
    ffi.Pointer<ffi.Char> public_key_ptr,
    int public_key_len,
  ) {
    return _h_aes_create_encryption_cache(
      cache_handle,
      policy_ptr,
      public_key_ptr,
      public_key_len,
    );
  }

  late final _h_aes_create_encryption_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_create_encryption_cache');
  late final _h_aes_create_encryption_cache =
      _h_aes_create_encryption_cachePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, int)>();

  /// The function should be called to reclaim memory
  /// of the cache created using h_aes_create_encrypt_cache()
  /// # Safety
  int h_aes_destroy_encryption_cache(
    int cache_handle,
  ) {
    return _h_aes_destroy_encryption_cache(
      cache_handle,
    );
  }

  late final _h_aes_destroy_encryption_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'h_aes_destroy_encryption_cache');
  late final _h_aes_destroy_encryption_cache =
      _h_aes_destroy_encryption_cachePtr.asFunction<int Function(int)>();

  /// Encrypt a header using an encryption cache
  /// The symmetric key and header bytes are returned in the first OUT parameters
  /// # Safety
  int h_aes_encrypt_header_using_cache(
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    ffi.Pointer<ffi.Int> symmetric_key_len,
    ffi.Pointer<ffi.Char> header_bytes_ptr,
    ffi.Pointer<ffi.Int> header_bytes_len,
    int cache_handle,
    ffi.Pointer<ffi.Char> attributes_ptr,
    ffi.Pointer<ffi.Char> uid_ptr,
    int uid_len,
    ffi.Pointer<ffi.Char> additional_data_ptr,
    int additional_data_len,
  ) {
    return _h_aes_encrypt_header_using_cache(
      symmetric_key_ptr,
      symmetric_key_len,
      header_bytes_ptr,
      header_bytes_len,
      cache_handle,
      attributes_ptr,
      uid_ptr,
      uid_len,
      additional_data_ptr,
      additional_data_len,
    );
  }

  late final _h_aes_encrypt_header_using_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_encrypt_header_using_cache');
  late final _h_aes_encrypt_header_using_cache =
      _h_aes_encrypt_header_using_cachePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              int)>();

  /// Encrypt a header without using an encryption cache.
  /// It is slower but does not require destroying any cache when done.
  ///
  /// The symmetric key and header bytes are returned in the first OUT parameters
  /// # Safety
  int h_aes_encrypt_header(
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    ffi.Pointer<ffi.Int> symmetric_key_len,
    ffi.Pointer<ffi.Char> header_bytes_ptr,
    ffi.Pointer<ffi.Int> header_bytes_len,
    ffi.Pointer<ffi.Char> policy_ptr,
    ffi.Pointer<ffi.Char> public_key_ptr,
    int public_key_len,
    ffi.Pointer<ffi.Char> attributes_ptr,
    ffi.Pointer<ffi.Char> uid_ptr,
    int uid_len,
    ffi.Pointer<ffi.Char> additional_data_ptr,
    int additional_data_len,
  ) {
    return _h_aes_encrypt_header(
      symmetric_key_ptr,
      symmetric_key_len,
      header_bytes_ptr,
      header_bytes_len,
      policy_ptr,
      public_key_ptr,
      public_key_len,
      attributes_ptr,
      uid_ptr,
      uid_len,
      additional_data_ptr,
      additional_data_len,
    );
  }

  late final _h_aes_encrypt_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_encrypt_header');
  late final _h_aes_encrypt_header = _h_aes_encrypt_headerPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Create a cache of the User Decryption Key which can be re-used
  /// when decrypting multiple messages. This avoids having to re-instantiate
  /// the user key on the Rust side on every decryption which is costly.
  ///
  /// This method is to be used in conjunction with
  /// h_aes_decrypt_header_using_cache()
  ///
  /// WARN: h_aes_destroy_decryption_cache() should be called
  /// to reclaim the memory of the cache when done
  /// # Safety
  int h_aes_create_decryption_cache(
    ffi.Pointer<ffi.Int> cache_handle,
    ffi.Pointer<ffi.Char> user_decryption_key_ptr,
    int user_decryption_key_len,
  ) {
    return _h_aes_create_decryption_cache(
      cache_handle,
      user_decryption_key_ptr,
      user_decryption_key_len,
    );
  }

  late final _h_aes_create_decryption_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_create_decryption_cache');
  late final _h_aes_create_decryption_cache =
      _h_aes_create_decryption_cachePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>, int)>();

  /// The function should be called to reclaim memory
  /// of the cache created using h_aes_create_decryption_cache()
  /// # Safety
  int h_aes_destroy_decryption_cache(
    int cache_handle,
  ) {
    return _h_aes_destroy_decryption_cache(
      cache_handle,
    );
  }

  late final _h_aes_destroy_decryption_cachePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'h_aes_destroy_decryption_cache');
  late final _h_aes_destroy_decryption_cache =
      _h_aes_destroy_decryption_cachePtr.asFunction<int Function(int)>();

  /// Decrypt an encrypted header using a cache.
  /// Returns the symmetric key,
  /// the uid and additional data if available.
  ///
  /// No additional data will be returned if the `additional_data_ptr` is NULL.
  ///
  /// # Safety
  int h_aes_decrypt_header_using_cache(
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    ffi.Pointer<ffi.Int> symmetric_key_len,
    ffi.Pointer<ffi.Char> uid_ptr,
    ffi.Pointer<ffi.Int> uid_len,
    ffi.Pointer<ffi.Char> additional_data_ptr,
    ffi.Pointer<ffi.Int> additional_data_len,
    ffi.Pointer<ffi.Char> encrypted_header_ptr,
    int encrypted_header_len,
    int cache_handle,
  ) {
    return _h_aes_decrypt_header_using_cache(
      symmetric_key_ptr,
      symmetric_key_len,
      uid_ptr,
      uid_len,
      additional_data_ptr,
      additional_data_len,
      encrypted_header_ptr,
      encrypted_header_len,
      cache_handle,
    );
  }

  late final _h_aes_decrypt_header_using_cachePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int)>>('h_aes_decrypt_header_using_cache');
  late final _h_aes_decrypt_header_using_cache =
      _h_aes_decrypt_header_using_cachePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              int,
              int)>();

  /// # Safety
  int h_get_encrypted_header_size(
    ffi.Pointer<ffi.Char> encrypted_ptr,
    int encrypted_len,
  ) {
    return _h_get_encrypted_header_size(
      encrypted_ptr,
      encrypted_len,
    );
  }

  late final _h_get_encrypted_header_sizePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'h_get_encrypted_header_size');
  late final _h_get_encrypted_header_size = _h_get_encrypted_header_sizePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Decrypt an encrypted header returning the symmetric key,
  /// the uid and additional data if available.
  ///
  /// Slower tha using a cache but avoids handling the cache creation and
  /// destruction.
  ///
  /// No additional data will be returned if the `additional_data_ptr` is NULL.
  ///
  /// # Safety
  int h_aes_decrypt_header(
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    ffi.Pointer<ffi.Int> symmetric_key_len,
    ffi.Pointer<ffi.Char> uid_ptr,
    ffi.Pointer<ffi.Int> uid_len,
    ffi.Pointer<ffi.Char> additional_data_ptr,
    ffi.Pointer<ffi.Int> additional_data_len,
    ffi.Pointer<ffi.Char> encrypted_header_ptr,
    int encrypted_header_len,
    ffi.Pointer<ffi.Char> user_decryption_key_ptr,
    int user_decryption_key_len,
  ) {
    return _h_aes_decrypt_header(
      symmetric_key_ptr,
      symmetric_key_len,
      uid_ptr,
      uid_len,
      additional_data_ptr,
      additional_data_len,
      encrypted_header_ptr,
      encrypted_header_len,
      user_decryption_key_ptr,
      user_decryption_key_len,
    );
  }

  late final _h_aes_decrypt_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_decrypt_header');
  late final _h_aes_decrypt_header = _h_aes_decrypt_headerPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// # Safety
  int h_aes_symmetric_encryption_overhead() {
    return _h_aes_symmetric_encryption_overhead();
  }

  late final _h_aes_symmetric_encryption_overheadPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>(
          'h_aes_symmetric_encryption_overhead');
  late final _h_aes_symmetric_encryption_overhead =
      _h_aes_symmetric_encryption_overheadPtr.asFunction<int Function()>();

  /// # Safety
  int h_aes_encrypt_block(
    ffi.Pointer<ffi.Char> encrypted_ptr,
    ffi.Pointer<ffi.Int> encrypted_len,
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    int symmetric_key_len,
    ffi.Pointer<ffi.Char> uid_ptr,
    int uid_len,
    int block_number,
    ffi.Pointer<ffi.Char> data_ptr,
    int data_len,
  ) {
    return _h_aes_encrypt_block(
      encrypted_ptr,
      encrypted_len,
      symmetric_key_ptr,
      symmetric_key_len,
      uid_ptr,
      uid_len,
      block_number,
      data_ptr,
      data_len,
    );
  }

  late final _h_aes_encrypt_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_encrypt_block');
  late final _h_aes_encrypt_block = _h_aes_encrypt_blockPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// # Safety
  int h_aes_decrypt_block(
    ffi.Pointer<ffi.Char> clear_text_ptr,
    ffi.Pointer<ffi.Int> clear_text_len,
    ffi.Pointer<ffi.Char> symmetric_key_ptr,
    int symmetric_key_len,
    ffi.Pointer<ffi.Char> uid_ptr,
    int uid_len,
    int block_number,
    ffi.Pointer<ffi.Char> encrypted_bytes_ptr,
    int encrypted_bytes_len,
  ) {
    return _h_aes_decrypt_block(
      clear_text_ptr,
      clear_text_len,
      symmetric_key_ptr,
      symmetric_key_len,
      uid_ptr,
      uid_len,
      block_number,
      encrypted_bytes_ptr,
      encrypted_bytes_len,
    );
  }

  late final _h_aes_decrypt_blockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('h_aes_decrypt_block');
  late final _h_aes_decrypt_block = _h_aes_decrypt_blockPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          int,
          ffi.Pointer<ffi.Char>,
          int)>();

  void log(
    ffi.Pointer<ffi.Int> s,
  ) {
    return _log(
      s,
    );
  }

  late final _logPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>)>>(
          'log');
  late final _log = _logPtr.asFunction<void Function(ffi.Pointer<ffi.Int>)>();

  void alert(
    ffi.Pointer<ffi.Int> s,
  ) {
    return _alert(
      s,
    );
  }

  late final _alertPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Int>)>>(
          'alert');
  late final _alert =
      _alertPtr.asFunction<void Function(ffi.Pointer<ffi.Int>)>();
}

const int MAX_CLEAR_TEXT_SIZE = 1073741824;
